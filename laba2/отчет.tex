\documentclass [12pt]{article}


\usepackage{ucs}
\usepackage[utf8x]{inputenc} %Поддержка UTF8
\usepackage{cmap} % Улучшенный поиск русских слов в полученном pdf-файле
\usepackage[english,russian]{babel} %Пакет для поддержки русского и английского языка
\usepackage{graphicx} %Поддержка графиков
\usepackage{float} %Поддержка float-графиков
\usepackage[left=20mm,right=15mm, top=20mm,bottom=20mm,bindingoffset=0cm]{geometry}
\usepackage{mathtools} 
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\renewcommand{\baselinestretch}{1.2}
 
\usepackage{color} 
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

\usepackage{listings}
 
\lstset{
	language=Python,
	basicstyle=\ttm,
	otherkeywords={self},             % Add keywords here
	keywordstyle=\ttb\color{deepblue},
	emph={MyClass,__init__},          % Custom highlighting
	emphstyle=\ttb\color{deepred},    % Custom highlighting style
	stringstyle=\color{deepgreen},
	frame=tb,                         % Any extra options here
	showstringspaces=false            % 
}
 
\usepackage{hyperref}
 
\hypersetup{
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={My title},    % title
    pdfauthor={Author},     % author
    pdfsubject={Subject},   % subject of the document
    pdfcreator={Creator},   % creator of the document
    pdfproducer={Producer}, % producer of the document
    pdfkeywords={keyword1} {key2} {key3}, % list of keywords
    pdfnewwindow=true,      % links in new PDF window
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=black,          % color of internal links (change box color with linkbordercolor)
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

\title{}
\date{}
\author{}

\begin{document}
\begin{titlepage}
\thispagestyle{empty}
\begin{center}
Федеральное государственное бюджетное образовательное учреждение высшего профессионального образования \\Московский государственный технический университет имени Н.Э. Баумана

\end{center}
\vfill
\centerline{\large{Лабораторная работа №2}}
\centerline{\large{по курсу <<Численные методы>>}}
\centerline{\large{<<Сравнительный анализ методов численного интегрирования>>}}
\vfill
\hfill\parbox{5cm} {
           Выполнил:\\
           студент группы ИУ9-62Б \hfill \\
           Головкин Дмитрий\hfill \medskip\\
           Проверила:\\
           Домрачева А.Б.\hfill
       }
\centerline{Москва, 2023}
\clearpage
\end{titlepage}
\textsc{\textbf{Цель:}} 
\\ Сравнительный анализ методов численного интегрирования:
\begin{enumerate}
\item Метод средних прямоугольников
\item Метод трапеций
\item Метод парабол (метод Симпсона)
\end{enumerate}

\textsc{\textbf{Постановка задачи:}}

\textbf{Дано:}  Интеграл $$\int\limits_a^b f(x)\,dx $$где $f(x)$ - подынтегральная функция, непрерывная на отрезке$[a,b]$.

\textbf{Найти:} значение интеграла $$I^{*} \approx  I $$

\textbf{Тестовый пример:} $$ I = \int\limits_0^1 e^x\,dx = e^x \bigg|_0^1 = e - 1 = 1.718282$$

\textsc{\textbf{Теоретические сведения:}}

Численное интегрирование — вычисление значения определённого интеграла (как правило, приближённое). Суть численного интегрирования состоит в расчёте значения определённого интеграла по взвешенным значениям подынтегральной функции, без использования первообразной функции.

Задача численного интегрирования состоит в замене исходной подинтегральной функции $f(x)$, для которой трудно или невозможно записать первообразную в аналитике, некоторой аппроксимирующей функцией $\phi(x)$. Такой функцией обычно является полином (кусочный полином).$$\phi(x)=\sum\limits_1^n c_{i}\varphi_{i}(x)$$То есть вычисление интеграла сводится к $$I=\int\limits_a^b f(x)\,dx = \int\limits_a^b \phi(x)\,dx + R$$ где $R=\int\limits_a^b r(x)\,dx $ - априорная погрешность метода на интервале интегрирования, а $r(x)$ - априорная погрешность метода на отдельном шаге интегрирования. 

В зависимости от степени и вида аппроксимисирующего полинома имеем различные численные методы интегрирования. Различают метод прямоугольников (левых, правых, средних), метод трапеций, метод парабол (метод Симпсона), метод Гаусса, метод Гаусса-Кронрода, метод Чебышёва, метод Монте-Карло. 

В ходе данной лабораторной работы рассмотрим первые три метода, а именно метод прямоугольников, метод трапеций, метод парабол (Симпсона). Степени кусочных полиномов будут соотвественно равны нулю, единице, двойке.

\textbf{1. Метод средних прямоугольников:}

Метод прямоугольников — метод численного интегрирования функции одной переменной, заключающийся в замене подынтегральной функции на полином нулевой степени - отрезком, параллельным оси абсцисс. Если рассмотреть график подынтегральной функции, то метод будет заключаться в приближённом вычислении площади под графиком суммированием площадей конечного числа прямоугольников, ширина которых будет определяться расстоянием между соответствующими соседними узлами интегрирования, а высота — значением подынтегральной функции в этих узлах.

Пусть требуется определить значение интеграла функции на отрезке $[a,b]$. Тогда разобьем этот отрезок на $n$ равных отрезков длиной $h=\frac{b-a}{n}$. Получим разбиение данного отрезка точками: $$x_{0} = a, x_{1} = x_{0} + h, x_{2} = x_{1} + h, ... , x_{n} = x_{n-1} + h = b $$

Значение интеграла на частичном отрезке $[x_{j-1},x_{j}]$ будет вычисляться по формуле: $$\int\limits_{x_{j-1}}^{x_{j}} f(x)\,dx \approx f(\frac{x_{j-1}+x_{j}}{2})h$$

Тогда применяя данную формулу ко всем отрезкам, составленных из разбиения отрезка $[a,b]$, получим приближенное значение интеграла на данном отрезке: $$I^{*} = \int\limits_{a}^{b} f(x)\,dx \approx h\sum\limits_{i=1}^n f(\frac{x_{j-1}+x_{j}}{2}) = h\sum\limits_{i=1}^n f(a+i*h-\frac{h}{2})$$

\textbf{2. Метод трапеций:}

Метод трапеций — метод численного интегрирования функции одной переменной, заключающийся в замене подынтегральной функции на полином первой степени - отрезком, параллельным оси абсцисс. Если рассмотреть график подынтегральной функции, то метод будет заключаться в приближённом вычислении площади под графиком суммированием площадей конечного числа прямоугольных трапеций, высота которых будет определяться расстоянием между соответствующими соседними узлами интегрирования, а основания — значениями подынтегральной функции в этих узлах.

Пусть требуется определить значение интеграла функции на отрезке $[a,b]$. Тогда разобьем этот отрезок на $n$ равных отрезков длиной $h=\frac{b-a}{n}$. Получим разбиение данного отрезка точками: $$x_{0} = a, x_{1} = x_{0} + h, x_{2} = x_{1} + h, ... , x_{n} = x_{n-1} + h = b $$

Значение интеграла на частичном отрезке $[x_{j-1},x_{j}]$ будет вычисляться по формуле: $$\int\limits_{x_{j-1}}^{x_{j}} f(x)\,dx \approx \frac{f(x_{j-1})+f(x_{j})}{2}h$$

Тогда применяя данную формулу ко всем отрезкам, составленных из разбиения отрезка $[a,b]$, получим приближенное значение интеграла на данном отрезке: $$I^{*} = \int\limits_{a}^{b} f(x)\,dx \approx \frac{h}{2}\sum\limits_{i=0}^n f(x_i) = h(\frac{f(a)+f(b)}{2}+\sum\limits_{i=1}^{n-1} f(x_i)))$$

\textbf{3. Метод Симпсона:}

Метод Симпсона — метод численного интегрирования функции одной переменной, заключающийся в приближении подынтегральной функции $[a;b]$ на интерполяционный полином второй степени, то есть квадратичной параболой $y=a_ix^2+b_ix+c_i$, проходящей через точки $(x_{i-1};f(x_{i-1}))$, $(x_{i-0.5};f(x_{i-0.5}))$, $(x_{i};f(x_{i}))$ Это делается для того, чтобы в качестве приближенного значения определенного интеграла  $\int\limits_{x_{j-1}}^{x_{j}} f(x)\,dx $ взять $\int\limits_{x_{j-1}}^{x_{j}} a_jx^2+b_jx+c_j\,dx $, который мы можем вычислить по формуле Ньютона-Лейбница.

Пусть требуется определить значение интеграла функции на отрезке $[a,b]$. Тогда разобьем этот отрезок на $n$ равных отрезков длиной $h=\frac{b-a}{n}$. Получим разбиение данного отрезка точками: $$x_{0} = a, x_{1} = x_{0} + h, x_{2} = x_{1} + h, ... , x_{n} = x_{n-1} + h = b $$

Парабола Симпсона представлена формулой:
$$ a_jx^2+b_jx+c_j = f(x_{i-0.5}) + \frac{f(x_{i})-f(x_{i-1})}{h}(x-x_{i-0.5}) + \frac{f(x_{i})-2f(x_{i-0.5})+f(x_{i-1})}{\frac{h^2}{2}}(x-x_{i-0.5})^2 $$

Значение интеграла на частичном отрезке $[x_{j-1},x_{j}]$ будет вычисляться по формуле: $$\int\limits_{x_{j-1}}^{x_{j}} f(x_{j-0.5})\,dx + \frac{f(x_{j})-f(x_{j-1})}{h}\int\limits_{x_{j-1}}^{x_{j}}(x-x_{j-0.5})\,dx + \frac{f(x_{j})-2f(x_{j-0.5})+f(x_{j-1})}{\frac{h^2}{2}}\int\limits_{x_{j-1}}^{x_{j}}(x-x_{j-0.5})^2\,dx =$$ $$ = \frac{h}{6}(f(x_{j-1})+4f(x_{j-0.5})+f(x_{j}))$$

Тогда применяя данную формулу ко всем отрезкам, составленных из разбиения отрезка $[a,b]$, получим приближенное значение интеграла на данном отрезке: $$I^{*} = \int\limits_{a}^{b} f(x)\,dx \approx \frac{h}{6}(f(a)+f(b)+4\sum\limits_{i=1}^n f(x_{i-0.5}) + 2\sum\limits_{i=1}^{n-1} f(x_i)))$$

\textbf{Вычисление интервалов различными методами с учётом погрешности:}

$I = \int\limits_a^b f(x)\,dx $

$I = I^{*} + O(h^k)$, где $k$ - порядок точности метода.

$k = 2$ - для методов средних прямоугольников и трапеций.
$k = 4$ - для методов Симпсона.

$O(h^k) \approx ch^k$, где $h$ - шаг, $c$ - некоторая константа. Равенство приблизительное из-за вычислительной погрешности.

Тогда:
$I \approx I^{*}_{h} + ch^k$, где $I^{*}_{h}$ - приближенное значение интеграла, вычисленного с помощью определенного метода с шагом $h$

Считаем, что вычисления проводятся без вычислительной погрешности, можно записать строгое равенство:
$$I = I^{*}_{h} + ch^k$$

Соответственно, при вычислении значения интеграл с шагом метода $\frac{h}{2}$ равенство будет иметь вид:
$$I = I^{*}_{\frac{h}{2}} + c(\frac{h}{2})^k$$

Из двух равенств следует равенство:

$$I^{*}_{h} + ch^k = I^{*}_{\frac{h}{2}} + c(\frac{h}{2})^k$$
$$c(\frac{h}{2})^k = \frac{I^{*}_{h} - I^{*}_{\frac{h}{2}}}{1-2^k}$$

Тогда получим значение интеграла с погрешностью:

$$I = I^{*}_{\frac{h}{2}} + \frac{I^{*}_{h} - I^{*}_{\frac{h}{2}}}{1-2^k}$$

где значение R уточнение по Ричардсону:

$$R =  \frac{I^{*}_{h} - I^{*}_{\frac{h}{2}}}{1-2^k}$$ 

Далее, используем правило Рунге, чтобы построить процедуру приближенного вычисления интеграла с заданной точностью $\varepsilon$ . Будем начинать вычисления с некоторого значения шага $h$, затем последовательно уменьшать это значения в два раза, каждый раз вычисляя приближенное значение $I^{*}_{h}$. Условие остановки приближенного вычисления интеграла с заданной точностью $\varepsilon$ c уточнением по Ричардсону: $$\abs{R}<\varepsilon$$

\textsc{\textbf{Практическая реализация:}}
Листинг 1. Численное интегрирование
\begin{lstlisting}[language=python]

#!python
# -*- coding: utf-8 -*-
import math

def analizing_function(x):
    return math.exp(x)


def rectange_method(a, b, n):
    h = (b - a) / n
    sum = 0.0
    for i in range(1, n+1):
        sum += (analizing_function(a + (i-1)*h) + analizing_function(a + i*h)) / 2
    return sum * h


def trapeze_method(a, b, n):
    h = (b - a) / n
    #print((b-a), n, (b - a) / n)
    sum = 0.0
    for i in range(1, n):
        sum += analizing_function(a + i*h)
    return (sum + (analizing_function(a) + analizing_function(b)) / 2) * h


def simpson_method(a, b, n):
    h = (b - a) / n
    sum = 0.0
    for i in range(1, n+1):
        f_xi = analizing_function(a + i*h)
        f_xi_m = (analizing_function(a + (i-1)*h) + analizing_function(a + i*h)) / 2
        f_xi_minus = analizing_function(a + (i-1)*h)
        sum += f_xi + 4*f_xi_m + f_xi_minus
    return sum * h / 6


def calculate_Richardson(i_h_div2, i_h, method):
    if method.__name__ == 'simpson_method':
        return (i_h_div2 - i_h) / 15
    return (i_h_div2 - i_h) / 3


def perform_computation(a, b, method):
    integral_values = {}
    epsilon = 1e-3
    n = 1
    num_steps = 0
    integral_values[(b - a) / n] = method(a, b, n)
    while True:
        n *= 2
        integral_values[(b - a) / n] = method(a, b, n)
        #print(integral_values[(b - a) / n], integral_values[(b - a) / (n / 2)])
        r = calculate_Richardson(integral_values[(b - a) / n], integral_values[(b - a) / (n / 2)], method)
        #print(r)
        num_steps += 1
        if r < epsilon and r > -epsilon:
            break
    return method.__name__, n, integral_values[(b - a) / (n)], r + integral_values[(b - a) / (n)], num_steps


def main():

    method_name, n, i, i_plus_r, num_steps = perform_computation(0, 1, rectange_method)
    print(method_name, "n =",n, "h/2 =", i, "h/2 + r =", i_plus_r, "number of steps=", num_steps)

    method_name, n, i, i_plus_r, num_steps = perform_computation(0, 1, trapeze_method)
    print(method_name, "n =",n, "h/2 =", i, "h/2 + r =", i_plus_r, "number of steps=", num_steps)

    method_name, n, i, i_plus_r, num_steps = perform_computation(0, 1, simpson_method)
    print(method_name, "n =",n, "h/2 =", i, "h/2 + r =", i_plus_r, "number of steps=", num_steps)


if __name__ == '__main__':
    main()


\end{lstlisting}

\textsc{\textbf{Результаты:}}

Для тестирования полученной программы были выбраны интегралы $$ I = \int\limits_0^1 e^x\,dx = e^x \bigg|_0^1 = e - 1 = 1.718282$$ и $$ I = \int\limits_0^\pi 2*x*\cos{x/2}\, dx$$

В качестве  $\varepsilon$ для каждого метода были выбраны следующие значения: $$\varepsilon=0.1,\varepsilon=0.01,\varepsilon=0.001$$

Ниже приведена таблица результата полученной программы (Листинг 1) на указанных выше методах:

\begin{center}
\begin{tabular}{ |l|l|l|l| }
  \hline
   Метод & \parbox[t]{2cm} {Кол-во \\ итераций} & \parbox[t]{4cm}{Значение интеграла \\ без уточнения по \\ Ричардсону} & \parbox[t]{4cm}{Значение интеграла \\ c уточнением по \\ Ричардсону} \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.1 , I = e^x$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 1 & 1.7539310924648255 & 1.718861151876593 \\ \hline
  Метод трапеций & 1 & 1.7539310924648253 & 1.7188611518765928 \\ \hline
  Метод Симпсона & 1 & 1.7182841546998966 & 1.746917104347179 \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.01 , I = e^x$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 2 & 1.7272219045575166 & 1.718318841921747 \\ \hline
  Метод трапеций & 2 & 1.7272219045575166 & 1.718318841921747 \\ \hline
  Метод Симпсона & 1 & 1.7539310924648255 & 1.746917104347179 \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.001, I = e^x$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 4 & 1.7180021920526605 & 1.7182817010716516 \\ \hline
  Метод трапеций & 4 & 1.7188411285799945 & 1.718281974051892 \\ \hline
  Метод Симпсона & 3 & 1.7182841546998966 & 1.7182818422184398 \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.1 , I = 2*x*\cos{x/2}$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 1 & 0.9232474918005087 & 0.9384691351038873 \\ \hline
  Метод трапеций & 1 & 0.9232474918005087 & 0.9384691351038873 \\ \hline
  Метод Симпсона & 1 & 0.9232474918005087 & 0.9262918204611844 \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.01 , I = 2*x*\cos{x/2}$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 2 & 0.9345888125210384 & 0.938369252761215 \\ \hline
  Метод трапеций & 2 & 0.9345888125210384 & 0.938369252761215 \\ \hline
  Метод Симпсона & 1 & 0.9232474918005087 & 0.9262918204611844 \\ \hline
  \multicolumn{4}{|c|}{$\varepsilon=0.001 , I = 2*x*\cos{x/2}$} \\ \hline
  \parbox[t]{5cm} {Метод средних \\ прямоугольников } & 3 & 0.9374194992050904 & 0.9383630614331077 \\ \hline
  Метод трапеций & 3 & 0.9374194992050905 & 0.9383630614331079 \\ \hline
  Метод Симпсона & 2 & 0.9345888125210383 & 0.9353449005690736 \\ \hline
\end{tabular}
\end{center}

\textsc{\textbf{Выводы:}}

В ходе выполнения лабораторной работы были рассмотрены три различных численных метода интегрирования: метод средних прямоугольников, метод трапеций, метод парабол (Симпсона). Была написана реализация данных методов на языке программирования Python.

Сравнивая результаты в таблице вычислений, метод парабол (Симпсона) является наиболее точным по сравнению с другими численными методами (меньшее количество итераций и более точный результат вычислений). 

Кроме этого, анализируя оставшиеся два метода численного интегрирования, метод средних прямоугольников точнее, чем метод трапеций, так как погрешность метода трапеций в два раза выше, чем у метода средних прямоугольников. Однако на практике найти среднее значение на элементарном интервале можно только у функций, заданных аналитически (а не таблично), поэтому использовать метод средних прямоугольников удаётся далеко не всегда в отличие от метода трапеций с произвольным шагом. В силу разных знаков погрешности в формулах трапеций и средних прямоугольников истинное значение интеграла обычно лежит между двумя этими оценками.

\end{document}
